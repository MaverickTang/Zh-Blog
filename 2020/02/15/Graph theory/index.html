<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/Blogs/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/Blogs/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/Blogs/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/Blogs/images/logo.svg" color="#222">

<link rel="stylesheet" href="/Blogs/css/main.css">


<link rel="stylesheet" href="/Blogs/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"mavericktang.github.io","root":"/Blogs/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","width":320,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Graph theory in Computer competitionIntroGraph theory is prabobly the most popular question in computer competition in USACO and NOIP(China). It is actually a branch of math theory. In the questions t">
<meta property="og:type" content="article">
<meta property="og:title" content="Graph theory">
<meta property="og:url" content="https://mavericktang.github.io/Blogs/2020/02/15/Graph%20theory/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Graph theory in Computer competitionIntroGraph theory is prabobly the most popular question in computer competition in USACO and NOIP(China). It is actually a branch of math theory. In the questions t">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/MaverickTang/Images/master/Undirected.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MaverickTang/Images/master/Directed.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MaverickTang/Images/master/DFS.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MaverickTang/Images/master/BFS.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MaverickTang/Images/master/Djk.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/MaverickTang/Images/master/Floyd.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MaverickTang/Images/master/SPFA.gif">
<meta property="article:published_time" content="2020-02-16T02:32:35.000Z">
<meta property="article:modified_time" content="2020-02-17T19:31:07.022Z">
<meta property="article:author" content="Haotian Tang">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="Competition">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/MaverickTang/Images/master/Undirected.png">

<link rel="canonical" href="https://mavericktang.github.io/Blogs/2020/02/15/Graph%20theory/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>
<script type="text/javascript">
  // Wait for the page to load first
  var _prevOnload = window.onload;
  window.onload = function() {
      var switchLang = document.getElementsByClassName("menu-item menu-item-switch_lang")[0];
      switchLang.onclick = function() {
          var href = window.location.href;
          var indexOfEn = href.toLowerCase().indexOf('/en/');
          if(indexOfEn !== -1) {
              window.location.href = href.replace('/en/', '/');
          }
          else {
              window.location.href = href.replace(/(^http[s]?:\/\/[a-z0-9.]*[:?0-9]*\/)(.*)/i, '$1en/$2');
          }
          if(typeof(_prevOnload) === 'function') {
              _prevOnload();
          }
          return false;
      }
  }
</script>j

  <title>Graph theory | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/Blogs/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">if(Coding == Happiness && Happiness == Life)</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/Blogs/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/Blogs/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/Blogs/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/Blogs/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-switch_lang">

    <a href="https://mavericktang.github.io/en" rel="section"><i class="fa fa-fw fa-language"></i>English</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="search-pop-overlay">
  <div class="popup search-popup">
      <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

  </div>
</div>

  </div>
</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/MaverickTang" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="https://mavericktang.github.io/Blogs/2020/02/15/Graph%20theory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blogs/images/avatar.gif">
      <meta itemprop="name" content="Haotian Tang">
      <meta itemprop="description" content="Live without Barricades!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Graph theory
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-15 18:32:35" itemprop="dateCreated datePublished" datetime="2020-02-15T18:32:35-08:00">2020-02-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-17 11:31:07" itemprop="dateModified" datetime="2020-02-17T11:31:07-08:00">2020-02-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Blogs/categories/Blog/" itemprop="url" rel="index"><span itemprop="name">Blog</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span></span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Graph-theory-in-Computer-competition"><a href="#Graph-theory-in-Computer-competition" class="headerlink" title="Graph theory in Computer competition"></a><strong>Graph theory</strong> in Computer competition</h1><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>Graph theory is prabobly the most popular question in computer competition in USACO and NOIP(China). It is actually a branch of math theory. In the questions they would give you many points in a graph and ask you to find out the shortest way or the possile way to go from one point to another one. Sometimes it will provide you with values of the edge and ask you to calculate the smallest coast. Sounds pretty simple Hahhhhh. Let’s have a look!</p>
<h2 id="Basic-Information"><a href="#Basic-Information" class="headerlink" title="Basic Information"></a>Basic Information</h2><p><strong>PS</strong>: You can jump to next block and keep reading, and find the concept you don’t understand above.</p>
<p><strong>Graph</strong> is a <a href="https://en.wikipedia.org/wiki/Tuple" target="_blank" rel="noopener">2-tuple</a> which describes the relationship between the points. Usually explained as G=(V,E), and V, E are mutiple sets.</p>
<p>Graph has two different types:</p>
<p><strong>Undirected graph</strong>: Every elements in E are disordered 2-tuple(u,v), we name the element <strong>Undirected edge</strong>. And u,v$\in$V. Let e=(u,v), then u and v are e’s <strong>endpoint</strong></p>
<p><img src="https://raw.githubusercontent.com/MaverickTang/Images/master/Undirected.png" alt="**Undirected graph**"></p>
<p><strong>Directed graph</strong>: Every elements in E are ordered 2-tuple, write as u$\longrightarrow$v, we name the element <strong>Directed edge</strong>.  Let e=u$\longrightarrow$v, then u is e’s <strong>Tail</strong>, and v is e’s <strong>head</strong>.</p>
<p><img src="https://raw.githubusercontent.com/MaverickTang/Images/master/Directed.png" alt="**directed graph**"></p>
<p>And for every elements in V, we call it <strong>Vertex</strong> or <strong>Node</strong>.</p>
<p>…….</p>
<p>Actually there is a lot more concept we need to know for the Graph Theory, but we are just programmers(<del>I don’t want to write down</del>) Here is the link for <a href="https://oi-wiki.org/graph/concept/" target="_blank" rel="noopener">More basic info</a>.</p>
<h2 id="Restore-the-graph"><a href="#Restore-the-graph" class="headerlink" title="Restore the graph!"></a>Restore the graph!</h2><p>After we study the basic information, know we need to know how to restore those information about a graph in our computer.</p>
<p>There are three ways we use to restore graphs.</p>
<p>But to make it easy(<del>I have no idea how to use the other two</del>), I will only show the one that is most easy(<del>Even can be mastered by the damn author</del>)</p>
<p>Actually, Forward star can widely use on different kind of graphs, this is the main reason I introduce it.</p>
<h3 id="Forward-Star"><a href="#Forward-Star" class="headerlink" title="Forward Star"></a>Forward Star</h3><p>We first use Struct to store the information about the graph.</p>
<p>We need to restore the basic info in the graph. Based on <strong>edge</strong>. So here are the info we need to restore in the <a href="http://www.cplusplus.com/doc/tutorial/structures/" target="_blank" rel="noopener">struct</a>:  The value of the edge, the point the edge go to, the next edge.</p>
<p>So here is the code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">       <span class="keyword">int</span> dest;<span class="comment">//destination</span></span><br><span class="line">       <span class="keyword">int</span> val;<span class="comment">//edge's value</span></span><br><span class="line">       <span class="keyword">int</span> next;<span class="comment">//next edge</span></span><br><span class="line">  &#125;eg[mx*<span class="number">2</span>];<span class="comment">//mx is the numer of the edges, if it is undirected you need to double</span></span><br><span class="line"><span class="keyword">int</span> n,m;<span class="comment">//nomber of point in the graph，number of edge in the graph </span></span><br><span class="line"><span class="keyword">int</span> head[MAX]=&#123;<span class="number">0</span>&#125;;<span class="comment">//The head in the graph</span></span><br><span class="line"><span class="keyword">int</span> top=<span class="number">0</span>;<span class="comment">//The exact number of the edeges</span></span><br></pre></td></tr></table></figure>



<p>Then we add the data into the struct</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> val)</span></span>&#123; </span><br><span class="line">    eg[++top].dest=v;<span class="comment">//v is the tail of the edge(destination)</span></span><br><span class="line">    eg[top].val=val;<span class="comment">//edge's value</span></span><br><span class="line">    eg[top].next=head[u];<span class="comment">//next edge's number</span></span><br><span class="line">    head[u]=top;<span class="comment">//Remeber this edge as another edge for the head u.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And here is the code in main function:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> u,v,val,i;</span><br><span class="line">   <span class="built_in">scanf</span>(“%d%d”,&amp;n,&amp;m);</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)<span class="comment">//input the numer of edges</span></span><br><span class="line">     <span class="built_in">scanf</span>(“%d%d%d”,&amp;u,&amp;v,&amp;val);<span class="comment">//input the head, tail, and value</span></span><br><span class="line">     addedge(u,v,val);<span class="comment">//directed graph</span></span><br><span class="line">     <span class="comment">//addedge(v,u,val);//If it is undirected graph</span></span><br><span class="line">   &#125;</span><br><span class="line">.....<span class="comment">//Other code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This way we make the restorage logical and easy. Then we can actually do something with the theory.</p>
<h2 id="Graph-traversal"><a href="#Graph-traversal" class="headerlink" title="Graph traversal"></a><a href="https://en.wikipedia.org/wiki/Graph_traversal" target="_blank" rel="noopener">Graph traversal</a></h2><p>Find the relationship between two points in a graph can be seen as travel in the graph. And we need to know the basic how to travel through the whole graph.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travel</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;<span class="comment">//Starting point</span></span><br><span class="line">	<span class="keyword">for</span>(i=head[s]; i ; i=eg[i].next)&#123;</span><br><span class="line">       <span class="built_in">printf</span>(“%d-&gt;%d=%d\n”,</span><br><span class="line">       s,eg[i].dest,eg[i].val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>But this kind of method is slow and do not fit most of the situation. We need some spcial methods.</p>
<p>Then here are two big basic alograithm for Graph theory.</p>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>DFS,  full name <a href="https://en.wikipedia.org/wiki/Depth-first_search" target="_blank" rel="noopener">Depth First Search</a>.</p>
<p>To make it easy, the core of it is to follow one road till it is going to an end. We travel through every edges as long as the edge can be traveled through.</p>
<p><img src="https://raw.githubusercontent.com/MaverickTang/Images/master/DFS.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> vis[mx]=&#123;<span class="number">0</span>&#125;;<span class="comment">//To make sure you won't travel through the same edge over and over again</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	vis[s]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[s];i;i=eg[i].next)&#123;<span class="comment">//travel</span></span><br><span class="line">		<span class="keyword">if</span>(!vis[eg[i].dest])&#123;<span class="comment">//haven't travel through</span></span><br><span class="line">			dfs(eg[i].dest);<span class="comment">//Then travel</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Simple as this. </p>
<p>With the core of the dfs, we can solve some problems easily.</p>
<h3 id="USACO06DEC-Cow-Picnic"><a href="#USACO06DEC-Cow-Picnic" class="headerlink" title="[USACO06DEC] Cow Picnic"></a>[USACO06DEC] Cow Picnic</h3><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>The cows are having a picnic! Each of Farmer John’s <em>K</em> (1 ≤ <em>K</em> ≤ 100) cows is grazing in one of <em>N</em> (1 ≤ <em>N</em> ≤ 1,000) pastures, conveniently numbered 1…<em>N</em>. The pastures are connected by <em>M</em> (1 ≤ <em>M</em> ≤ 10,000) one-way paths (no path connects a pasture to itself).</p>
<p>The cows want to gather in the same pasture for their picnic, but (because of the one-way paths) some cows may only be able to get to some pastures. Help the cows out by figuring out how many pastures are reachable by all cows, and hence are possible picnic locations.</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>Line 1: Three space-separated integers, respectively: <em>K</em>, <em>N</em>, and <em>M</em><br>Lines 2..<em>K</em>+1: Line <em>i</em>+1 contains a single integer (1..<em>N</em>) which is the number of the pasture in which cow <em>i</em> is grazing.<br>Lines <em>K</em>+2..<em>M</em>+<em>K</em>+1: Each line contains two space-separated integers, respectively <em>A</em> and <em>B</em> (both 1..<em>N</em> and <em>A</em> != <em>B</em>), representing a one-way path from pasture <em>A</em> to pasture <em>B</em>.</p>
<h4 id="output"><a href="#output" class="headerlink" title="output"></a>output</h4><p>Line 1: The single integer that is the number of pastures that are reachable by all cows via the one-way paths.</p>
<h4 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h4><p>Input</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2 4 4</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">1 2</span><br><span class="line">1 4</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure>

<p>Output </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h4><p>Dfs search every cows, use field[i] express the numer i field have been tracel through how many times, if field[i]=k then meet the standard(Means every cow has traveled through here).</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mx=<span class="number">10005</span>;<span class="comment">//As the question given</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> dest,next;<span class="comment">//No value given</span></span><br><span class="line">&#125;eg[mx];</span><br><span class="line"><span class="keyword">int</span> head[mx],top=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> vis[mx],field[<span class="number">1005</span>],cow[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	eg[++top].dest=v,eg[top].next=head[u],head[u]=top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	vis[s]=<span class="number">1</span>;field[s]++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[s];i;i=eg[i].next)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[eg[i].dest])&#123;</span><br><span class="line">			dfs(eg[i].dest);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k,m,n,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="comment">//Speed up cin and cout</span></span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;k&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;cow[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> u,v;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">		addedge(u, v);<span class="comment">//Directed graph</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;<span class="comment">//Put vis back to 0 again</span></span><br><span class="line">			vis[j]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		dfs(cow[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(field[i]==k)ans++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>BFS, full name <strong>Breadth First Search</strong></p>
<p>BFS is a traversing algorithm where you should start traversing from a selected node (source or starting node) and traverse the graph layerwise thus exploring the neighbour nodes (nodes which are directly connected to source node). You must then move towards the next-level neighbour nodes.</p>
<p><img src="https://raw.githubusercontent.com/MaverickTang/Images/master/BFS.png" alt=""></p>
<p>Code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;//Import queue libaray</span></span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;<span class="comment">//Declare queue</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	q.push(s);vis[s]=<span class="number">1</span>;<span class="comment">//push s into the queue and vis</span></span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;<span class="comment">//As long as there is still elements in the queue</span></span><br><span class="line">		<span class="keyword">int</span> u=q.front();<span class="comment">//Get the front of the queue</span></span><br><span class="line">		q.pop();<span class="comment">//Get the front of the queue out</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=eg[i].next)&#123;<span class="comment">//Same old story</span></span><br><span class="line">			<span class="keyword">int</span> v=eg[i].dest;</span><br><span class="line">			<span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">				q.push(v),vis[v]=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Example</p>
<h3 id="USACO14DEC-Piggy-Back"><a href="#USACO14DEC-Piggy-Back" class="headerlink" title="[USACO14DEC] Piggy Back"></a>[USACO14DEC] Piggy Back</h3><h4 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h4><p>Bessie and her sister Elsie graze in different fields during the day, and in the evening they both want to walk back to the barn to rest. Being clever bovines, they come up with a plan to minimize the total amount of energy they both spend while walking.</p>
<p>Bessie spends B units of energy when walking from a field to an adjacent field, and Elsie spends E units of energy when she walks to an adjacent field. However, if Bessie and Elsie are together in the same field, Bessie can carry Elsie on her shoulders and both can move to an adjacent field while spending only P units of energy (where P might be considerably less than B+E, the amount Bessie and Elsie would have spent individually walking to the adjacent field). If P is very small, the most energy-efficient solution may involve Bessie and Elsie traveling to a common meeting field, then traveling together piggyback for the rest of the journey to the barn. Of course, if P is large, it may still make the most sense for Bessie and Elsie to travel</p>
<p>separately. On a side note, Bessie and Elsie are both unhappy with the term “piggyback”, as they don’t see why the pigs on the farm should deserve all the credit for this remarkable form of</p>
<p>transportation.</p>
<p>Given B, E, and P, as well as the layout of the farm, please compute the minimum amount of energy required for Bessie and Elsie to reach the barn.</p>
<h4 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h4><p>INPUT: (file piggyback.in)</p>
<p>The first line of input contains the positive integers B, E, P, N, and M. All of these are at most 40,000. B, E, and P are described above. N is the number of fields in the farm (numbered 1..N, where N &gt;= 3), and M is the number of connections between fields. Bessie and Elsie start in fields 1 and 2, respectively. The barn resides in field N.</p>
<p>The next M lines in the input each describe a connection between a pair of different fields, specified by the integer indices of the two fields. Connections are bi-directional. It is always possible to travel from field 1 to field N, and field 2 to field N, along a series of such connections.</p>
<h4 id="output-1"><a href="#output-1" class="headerlink" title="output"></a>output</h4><p>OUTPUT: (file piggyback.out)</p>
<p>A single integer specifying the minimum amount of energy Bessie and</p>
<p>Elsie collectively need to spend to reach the barn. In the example</p>
<p>shown here, Bessie travels from 1 to 4 and Elsie travels from 2 to 3</p>
<p>to 4. Then, they travel together from 4 to 7 to 8.</p>
<h4 id="Sample-1"><a href="#Sample-1" class="headerlink" title="Sample"></a>Sample</h4><p>Input:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">4 4 5 8 8 </span><br><span class="line">1 4 </span><br><span class="line">2 3 </span><br><span class="line">3 4 </span><br><span class="line">4 7 </span><br><span class="line">2 5 </span><br><span class="line">5 6 </span><br><span class="line">6 8 </span><br><span class="line">7 8</span><br></pre></td></tr></table></figure>

<p>Output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">22</span><br></pre></td></tr></table></figure>

<h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution:"></a>Solution:</h4><p>Because the shortest distance from one point to the destination is unchangable, so we don’t have to consider two of them meet together and depart. If B<em>+</em>E*&lt;=<em>P , then we should keep them being together；<br>If B</em>+<em>E &gt;*P</em> Then they’d better be apart.<br>So we only need to run bfs from 1,2,n. And get the shortest length. After we enumerate the points they will be together, we are done.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mx=<span class="number">40005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> dest,next;</span><br><span class="line">&#125;eg[mx];</span><br><span class="line"><span class="keyword">int</span> head[mx],top=<span class="number">0</span>,vis[<span class="number">3</span>][mx],dis[<span class="number">3</span>][mx];<span class="comment">//dis[][]is used to memorize the distance</span></span><br><span class="line"><span class="keyword">int</span> b,e,p,n,m,u,v;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;<span class="comment">//Same old story</span></span><br><span class="line">	eg[++top].dest=v;</span><br><span class="line">	eg[top].next=head[u];</span><br><span class="line">	head[u]=top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s==<span class="number">0</span>) vis[s][<span class="number">1</span>]=<span class="number">1</span>,q.push(<span class="number">1</span>);<span class="comment">//</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="number">1</span>) vis[s][<span class="number">2</span>]=<span class="number">1</span>,q.push(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">else</span> vis[s][n]=<span class="number">1</span>,q.push(n);</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> u=q.front();q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=eg[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v=eg[i].dest;</span><br><span class="line">			<span class="keyword">if</span>(!vis[s][v])&#123;</span><br><span class="line">				dis[s][v]=dis[s][u]+<span class="number">1</span>;<span class="comment">//The distance to the head=the distance to the tail + 1</span></span><br><span class="line">				q.push(v);</span><br><span class="line">				vis[s][v]=<span class="number">1</span>;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;b&gt;&gt;e&gt;&gt;p&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">		addedge(u,v);</span><br><span class="line">		addedge(v, u);<span class="comment">//undirected graph</span></span><br><span class="line">	&#125;</span><br><span class="line">	bfs(<span class="number">0</span>);</span><br><span class="line">	bfs(<span class="number">1</span>);</span><br><span class="line">	bfs(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">1e9</span>;<span class="comment">//Put ans to largest int, or it will be hard to replace with new value</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		ans=<span class="built_in">min</span>(ans, dis[<span class="number">0</span>][i]*b+dis[<span class="number">1</span>][i]*e+dis[<span class="number">2</span>][i]*p);<span class="comment">//As the question said</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="More-advanced-Algotithm"><a href="#More-advanced-Algotithm" class="headerlink" title="More advanced Algotithm"></a>More advanced Algotithm</h2><h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><p>It uses the idea of BFS, aims to solve the Shortest path problem. It works both well for Directed graph and undirected graph.  </p>
<p>The point of Djikstra is be greedy. We declare an array to restore the distance from the starting point to another point, initialize them as infinite number if there is no direct edge from starting point to them, and if they do have, put them as the smae value as the value of the edge .So that we can replace them with smaller number which we gained from the value of the route. As the graph.</p>
<p><img src="https://raw.githubusercontent.com/MaverickTang/Images/master/Djk.gif" alt=""></p>
<p>Dijkstra has Time complexity 𝑂(n^2), but with heap, it can be 𝑂((𝑛+𝑚)log2𝑛)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span><span class="comment">//Declare another struct to restore the information for the point</span></span><br><span class="line">	<span class="keyword">int</span> dis,pos;<span class="comment">//pos means the number of the point</span></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;( <span class="keyword">const</span> node &amp;x )<span class="keyword">const</span>&#123;<span class="comment">//declare the operator '&lt;' by our own function</span></span><br><span class="line">		<span class="keyword">return</span> x.dis &lt; dis;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::priority_queue&lt;node&gt; q;<span class="comment">//priority queue</span></span><br><span class="line"><span class="keyword">int</span> dis[mx],vis[mx];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	dis[s]=<span class="number">0</span>;</span><br><span class="line">	q.push((node)&#123;<span class="number">0</span>,s&#125;);<span class="comment">//push into queue as struct node</span></span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		node tmp=q.top();q.pop();</span><br><span class="line">		<span class="keyword">int</span> x=tmp.pos,d=tmp.dis;</span><br><span class="line">		<span class="keyword">if</span>(!vis[x])&#123;<span class="comment">//Got to the tail, if we didn't visit it</span></span><br><span class="line">		vis[x]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=eg[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> y=eg[i].dest;</span><br><span class="line">			<span class="keyword">if</span>(dis[y]&gt;dis[x]+eg[i].val)&#123;</span><br><span class="line">				dis[y]=dis[x]+eg[i].val;<span class="comment">//The core of the code, to replace for smaller</span></span><br><span class="line">				<span class="keyword">if</span>(!vis[y])<span class="comment">//Got to the head, if we didn't visit it</span></span><br><span class="line">					q.push((node)&#123;dis[y],y&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="USACO19DEC-Milk-Pumping-G"><a href="#USACO19DEC-Milk-Pumping-G" class="headerlink" title="[USACO19DEC]Milk Pumping G"></a>[USACO19DEC]Milk Pumping G</h3><h4 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h4><p>Farmer John has recently purchased a new farm to expand his milk production empire. The new farm is connected to a nearby town by a network of pipes, and FJ wants to figure out the best set of these pipes to purchase for his use in pumping milk from the farm to the town.</p>
<p>The network of pipes is described by NN junction points (endpoints of pipes), conveniently numbered 1…N1…N (2≤N≤10002≤N≤1000). Junction point 1 represents FJ’s farm and junction point NN is the town. There are MM bi-directional pipes (1≤M≤10001≤M≤1000), each joining a pair of junction points. The iith pipe costs cici dollars for FJ to purchase for his use, and can support a flow rate of fifi liters of milk per second.</p>
<p>FJ wants to purchase a single path worth of pipes, where the endpoints of the path are junctions 1 and NN. The cost of the path is the sum of the costs of the pipes along the path. The flow rate along the path is the minimum of the flow rates of the pipes along the path (since this serves as a bottleneck for the flow traveling down the path). FJ wants to maximize the flow rate of the path divided by the cost of the path. It is guaranteed that a path from 11 to NN exists.</p>
<h4 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h4><p>The first line of input contains NN and M.M. Each of the following MM lines describes a pipe in terms of four integers: aa and bb (the two different junctions connected by the pipe), cc (its cost), and ff (its flow rate). Cost and flow rate are both positive integers in the range 1…10001…1000.</p>
<h4 id="output-2"><a href="#output-2" class="headerlink" title="output"></a>output</h4><p>Please print 106106 times the optimal solution value, truncated to an integer (that is, rounded down to the next-lowest integer if this number is not itself an integer).</p>
<h4 id="Sample-2"><a href="#Sample-2" class="headerlink" title="Sample"></a>Sample</h4><p>Input:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br><span class="line">2 1 2 4</span><br><span class="line">2 3 5 3</span><br></pre></td></tr></table></figure>

<p>Output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">428571</span><br></pre></td></tr></table></figure>

<h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution:"></a>Solution:</h4><p>Just enumerate the biggest flow from 1 to 1000, and calculate for the smallest cost.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mx=<span class="number">2010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> dest,val,next,flow;</span><br><span class="line">&#125;eg[mx*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[mx],top=<span class="number">0</span>,vis[mx],dis[mx];</span><br><span class="line"><span class="keyword">int</span> n,m,ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> val,<span class="keyword">int</span> flow)</span></span>&#123;<span class="comment">//Same old story</span></span><br><span class="line">	eg[++top].dest=v;</span><br><span class="line">	eg[top].val=val;</span><br><span class="line">	eg[top].flow=flow;</span><br><span class="line">	eg[top].next=head[u];</span><br><span class="line">	head[u]=top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dij</span><span class="params">(<span class="keyword">int</span> flow)</span></span>&#123;</span><br><span class="line">	  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)dis[i]=INF,vis[i]=<span class="number">0</span>;<span class="comment">//Initialize dis and vis</span></span><br><span class="line">			dis[<span class="number">1</span>]=<span class="number">0</span>,vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">			q.push(<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">				<span class="keyword">int</span> u=q.front();q.pop();vis[u]=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=eg[i].next)&#123;</span><br><span class="line">					<span class="keyword">if</span>(eg[i].flow&lt;flow)<span class="keyword">continue</span>;<span class="comment">//Means we have already enumerated</span></span><br><span class="line">					<span class="keyword">int</span> t=eg[i].dest;</span><br><span class="line">					<span class="keyword">if</span>(dis[u]+eg[i].val&lt;dis[t])&#123;<span class="comment">//Everything can change, the core never change</span></span><br><span class="line">						dis[t]=dis[u]+eg[i].val;</span><br><span class="line">						<span class="keyword">if</span>(!vis[t])&#123;</span><br><span class="line">							vis[t]=<span class="number">1</span>;</span><br><span class="line">							q.push(t);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(dis[n]!=INF)ans=<span class="built_in">max</span>(ans,flow*<span class="number">1000000</span>/dis[n]);<span class="comment">//We got to the end, see if we can replace</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> a,b,c,d;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">		addedge(a, b, c, d);</span><br><span class="line">		addedge(b, a, c, d);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1000</span>;i++)<span class="comment">//from 1 to 1000 enumerate the smallest flow</span></span><br><span class="line">	dij(i);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h3><p>It solve the Shortest path problem between two points, unlike Dijkstra, Floyd allow us to deal with the edge which has negative value. But Floyd take more time complexity(O(n^3)). So we have to be careful about it.</p>
<p>Like Dijkstra, Floyd’s core is also enumerate. It enumerate every point by 3 for loops. Because we suppose there is a shorter way than directly get to the point. We use g[i] [j] to express the distance from i to j, so there might be a point k in between might make this case:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g[i][j]&gt;g[i][k]+g[k][j];</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/MaverickTang/Images/master/Floyd.png" alt=""></p>
<p>I think it is easier to understand by code:(Probably the shortest one you ever meet)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(g[i][k]&lt;inf&amp;&amp;g[k][j]&lt;inf&amp;&amp;g[i][j]&gt;g[i][k]+g[k][j])</span><br><span class="line">					g[i][j]=g[i][k]+g[k][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="USACO09DEC-Cow-Toll-Paths"><a href="#USACO09DEC-Cow-Toll-Paths" class="headerlink" title="[USACO09DEC]Cow Toll Paths"></a>[USACO09DEC]Cow Toll Paths</h3><h4 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h4><p>Like everyone else, FJ is always thinking up ways to increase his revenue. To this end, he has set up a series of tolls that the cows will pay when they traverse the cowpaths throughout the farm.</p>
<p>The cows move from any of the N (1 &lt;= N &lt;= 250) pastures conveniently numbered 1..N to any other pasture over a set of M (1 &lt;= M &lt;= 10,000) bidirectional cowpaths that connect pairs of different pastures A_j and B_j (1 &lt;= A_j &lt;= N; 1 &lt;= B_j &lt;= N). FJ has assigned a toll L_j (1 &lt;= L_j &lt;= 100,000) to the path connecting pastures A_j and B_j.</p>
<p>While there may be multiple cowpaths connecting the same pair of pastures, a cowpath will never connect a pasture to itself. Best of all, a cow can always move from any one pasture to any other pasture by following some sequence of cowpaths.</p>
<p>In an act that can only be described as greedy, FJ has also assigned a toll C_i (1 &lt;= C_i &lt;= 100,000) to every pasture. The cost of moving from one pasture to some different pasture is the sum of the tolls for each of the cowpaths that were traversed plus a <em>single additional toll</em> that is the maximum of all the pasture tolls encountered along the way, including the initial and destination pastures.</p>
<p>The patient cows wish to investigate their options. They want you to write a program that accepts K (1 &lt;= K &lt;= 10,000) queries and outputs the minimum cost of trip specified by each query. Query i is a pair of numbers s_i and t_i (1 &lt;= s_i &lt;= N; 1 &lt;= t_i &lt;= N; s_i != t_i) specifying a starting and ending pasture.</p>
<p>Consider this example diagram with five pastures:</p>
<p>The ‘edge toll’ for the path from pasture 1 to pasture 2 is 3. Pasture 2’s ‘node toll’ is 5.</p>
<p>To travel from pasture 1 to pasture 4, traverse pastures 1 to 3 to 5 to 4. This incurs an edge toll of 2+1+1=4 and a node toll of 4 (since pasture 5’s toll is greatest), for a total cost of 4+4=8.</p>
<p>The best way to travel from pasture 2 to pasture 3 is to traverse pastures 2 to 5 to 3. This incurs an edge toll of 3+1=4 and a node toll of 5, for a total cost of 4+5=9.</p>
<h4 id="Input-3"><a href="#Input-3" class="headerlink" title="Input"></a>Input</h4><p>* Line 1: Three space separated integers: N, M, and K</p>
<p>* Lines 2..N+1: Line i+1 contains a single integer: C_i</p>
<p>* Lines N+2..N+M+1: Line j+N+1 contains three space separated</p>
<p>integers: A_j, B_j, and L_j</p>
<p>* Lines N+M+2..N+M+K+1: Line i+N+M+1 specifies query i using two space-separated integers: s_i and t_i</p>
<h4 id="output-3"><a href="#output-3" class="headerlink" title="output"></a>output</h4><p>* Lines 1..K: Line i contains a single integer which is the lowest cost of any route from s_i to t_i</p>
<h4 id="Sample-3"><a href="#Sample-3" class="headerlink" title="Sample"></a>Sample</h4><p>Input:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">5 7 2 </span><br><span class="line">2 </span><br><span class="line">5 </span><br><span class="line">3 </span><br><span class="line">3 </span><br><span class="line">4 </span><br><span class="line">1 2 3 </span><br><span class="line">1 3 2 </span><br><span class="line">2 5 3 </span><br><span class="line">5 3 1 </span><br><span class="line">5 4 1 </span><br><span class="line">2 4 3 </span><br><span class="line">3 4 4 </span><br><span class="line">1 4 </span><br><span class="line">2 3</span><br></pre></td></tr></table></figure>

<p>Output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8 </span><br><span class="line">9</span><br></pre></td></tr></table></figure>

<h4 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution:"></a>Solution:</h4><p>N so small and asking so many. Definally Floyd. We use two arries <strong>dis</strong>[][] and <strong>dist</strong>[][] to memorize the value of the edges alone and the value of the edges add with the value of points. We enumerate the value of points from small to big for point k, then the last k we enumerate should have the biggest point value from a to b. And we compare it with i and j’s value we then get the biggest point value. Then we are done.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;//memset</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;//For sort</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k,dis[<span class="number">300</span>][<span class="number">300</span>],dist[<span class="number">300</span>][<span class="number">300</span>],c[<span class="number">300</span>];<span class="comment">//dis without point value, dist is with</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> d,id;</span><br><span class="line">&#125;x[<span class="number">300</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;<span class="comment">//use in the sort function</span></span><br><span class="line">	<span class="keyword">if</span>(a.d==b.d)</span><br><span class="line">		<span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">	<span class="keyword">return</span> a.d&lt;b.d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;<span class="comment">//Same old story</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(i==j) <span class="keyword">continue</span>;</span><br><span class="line">				dis[i][j]=<span class="built_in">min</span>(dis[i][j],dis[i][k]+dis[k][j]);<span class="comment">//Our original Floyd</span></span><br><span class="line">				dist[i][j]=<span class="built_in">min</span>(dist[i][j],dis[i][j]+<span class="built_in">max</span>(x[k].d,<span class="built_in">max</span>(x[i].d,x[j].d)));<span class="comment">//As said in the question</span></span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x[i].d;</span><br><span class="line">		x[i].id=i;</span><br><span class="line">		dis[i][i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(x+<span class="number">1</span>,x+<span class="number">1</span>+n,cmp);<span class="comment">//sort by the value of point</span></span><br><span class="line">	<span class="keyword">int</span> origin[<span class="number">300</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)origin[x[i].id]=i;<span class="comment">//question will ask the origin number, let's memorize it</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> a,b,c;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">		dis[origin[a]][origin[b]]=dis[origin[b]][origin[a]]=<span class="built_in">min</span>(dis[origin[b]][origin[a]],c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">	floyd();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">	<span class="keyword">int</span> a,b;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;(dist[origin[a]][origin[b]])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h3><p>SPFA, full name <strong>Shortest Path Faster Algorithm</strong>.</p>
<p>Sounds pretty cool Hahhh. Actually, I think it is the most useful algorithm for graph theory, it can deal with almost all kinds of graph. Now, let’s see how it works!</p>
<p>It works by repeatedly selecting a vertex and using it to relax, if possible, all of its neighbors. If a node was successfully relaxed, then it might in turn be necessary to use it to relax other vertices, and hence it is marked for consideration also. Once there are no vertices left to be considered, the algorithm terminates. Note that a vertex might be considered several times during the course of the algorithm. The usual implementation strategy is to use a <a href="http://wcipeg.com/wiki/Queue" target="_blank" rel="noopener">queue</a> to hold the vertices that might be considered next.</p>
<p><img src="https://raw.githubusercontent.com/MaverickTang/Images/master/SPFA.gif" alt=""></p>
<p>Code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u,v;    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dist));<span class="comment">//Initialize dist</span></span><br><span class="line">	dist[s]=<span class="number">0</span>;<span class="comment">//Get start point as 0</span></span><br><span class="line">	inque[s]=<span class="number">1</span>;<span class="comment">//Memorize the s is in the queue</span></span><br><span class="line">	q.push(s);<span class="comment">//in queue</span></span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		u=q.front(), q.pop();  inque[u]=<span class="number">0</span>;<span class="comment">//Get the front of queue out</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u]; i; i=eg[i].next)&#123;</span><br><span class="line">			  v=eg[i].dest;</span><br><span class="line">			  <span class="keyword">if</span>(dist[v]&gt;dist[u]+eg[i].val)&#123;<span class="comment">//If find a route with smaller value</span></span><br><span class="line">				  dist[v]= dist[u]+eg[i].val;<span class="comment">//change it </span></span><br><span class="line">				  fa[v]=u;<span class="comment">//Memorize the tail of v</span></span><br><span class="line">				  <span class="keyword">if</span>(!inque[v])&#123;</span><br><span class="line">					  q.push(v), inque[v]=<span class="number">1</span>;</span><br><span class="line">				  &#125;</span><br><span class="line">			  &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We see that spfa is pretty similar to Dijkstra. let me use the core code to express the difference.</p>
<h4 id="Difference-between-Dij-heap-and-SPFA"><a href="#Difference-between-Dij-heap-and-SPFA" class="headerlink" title="Difference between Dij+heap and SPFA!!!"></a>Difference between Dij+heap and SPFA!!!</h4><p>Dij:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">  <span class="comment">//If priority queue is not empty</span></span><br><span class="line">		node tmp=q.top();q.pop();</span><br><span class="line">  <span class="comment">//get top out</span></span><br><span class="line">		<span class="keyword">int</span> x=tmp.pos,d=tmp.dis;</span><br><span class="line">		<span class="keyword">if</span>(!vis[x])&#123;<span class="comment">//Got to the tail, if we didn't visit it</span></span><br><span class="line">		vis[x]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=eg[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> y=eg[i].dest;</span><br><span class="line">			<span class="keyword">if</span>(dis[y]&gt;dis[x]+eg[i].val)&#123;</span><br><span class="line">        <span class="comment">//Relax</span></span><br><span class="line">				dis[y]=dis[x]+eg[i].val;<span class="comment">//The core of the code, to replace for smaller</span></span><br><span class="line">				<span class="keyword">if</span>(!vis[y])<span class="comment">//Got to the head, if we didn't visit it</span></span><br><span class="line">					q.push((node)&#123;dis[y],y&#125;);</span><br><span class="line">        <span class="comment">//New distance and new point into the queue</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>SPFA:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">   <span class="comment">//if regular queue is not empty</span></span><br><span class="line">	u=q.front(), q.pop();  inque[u]=<span class="number">0</span>;<span class="comment">//Get the front of queue out</span></span><br><span class="line">   <span class="comment">//Get top out</span></span><br><span class="line">   <span class="comment">//And Remember!!!</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u]; i; i=eg[i].next)&#123;</span><br><span class="line">		  v=eg[i].dest;</span><br><span class="line">		  <span class="keyword">if</span>(dist[v]&gt;dist[u]+eg[i].val)&#123;<span class="comment">//If find a route with smaller value</span></span><br><span class="line">         <span class="comment">//Relax</span></span><br><span class="line">			  dist[v]= dist[u]+eg[i].val;<span class="comment">//change it </span></span><br><span class="line">			  fa[v]=u;<span class="comment">//Memorize the tail of v</span></span><br><span class="line">			  <span class="keyword">if</span>(!inque[v])&#123;</span><br><span class="line">           <span class="comment">//the points that are Relaxed but not in queue get into the queue</span></span><br><span class="line">				  q.push(v), inque[v]=<span class="number">1</span>;</span><br><span class="line">			  &#125;</span><br><span class="line">		  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So the difference is clear enough:</p>
<p>Dji+heap: <strong>Small root pile</strong>, every time get the shortest distance, for this point, the shortest distance <strong>won’t change</strong>! </p>
<p>SPFA: Use <strong>queue</strong>. Get the front out of queue, might be renew in the future, it is <strong>won’t be always the same</strong>. </p>
<h3 id="USACO14OPEN-Dueling-GPS’s"><a href="#USACO14OPEN-Dueling-GPS’s" class="headerlink" title="[USACO14OPEN]Dueling GPS’s"></a>[USACO14OPEN]Dueling GPS’s</h3><h4 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h4><p>Farmer John has recently purchased a new car online, but in his haste he accidentally clicked the “Submit” button twice when selecting extra features for the car, and as a result the car ended up equipped with two GPS navigation systems! Even worse, the two systems often make conflicting decisions about the route that FJ should take.</p>
<p>The map of the region in which FJ lives consists of N intersections (2 &lt;= N &lt;= 10,000) and M directional roads (1 &lt;= M &lt;= 50,000). Road i connects intersections A_i (1 &lt;= A_i &lt;= N) and B_i (1 &lt;= B_i &lt;= N). Multiple roads could connect the same pair of intersections, and a bi-directional road (one permitting two-way travel) is represented by two separate directional roads in opposite orientations. FJ’s house is located at intersection 1, and his farm is located at intersection N. It is possible to reach the farm from his house by traveling along a series of directional roads.</p>
<p>Both GPS units are using the same underlying map as described above; however, they have different notions for the travel time along each road. Road i takes P_i units of time to traverse according to the first GPS unit, and Q_i units of time to traverse according to the second unit (each travel time is an integer in the range 1..100,000).</p>
<p>FJ wants to travel from his house to the farm. However, each GPS unit complains loudly any time FJ follows a road (say, from intersection X to intersection Y) that the GPS unit believes not to be part of a shortest route from X to the farm (it is even possible that both GPS units can complain, if FJ takes a road that neither unit likes).</p>
<p>Please help FJ determine the minimum possible number of total complaints he can receive if he chooses his route appropriately. If both GPS units complain when FJ follows a road, this counts as +2 towards the total.</p>
<h4 id="Input-4"><a href="#Input-4" class="headerlink" title="Input"></a>Input</h4><p>* Line 1: The integers N and M.</p>
<p>Line i describes road i with four integers: A_i B_i P_i Q_i.</p>
<h4 id="output-4"><a href="#output-4" class="headerlink" title="output"></a>output</h4><p>* Line 1: The minimum total number of complaints FJ can receive if he routes himself from his house to the farm optimally.</p>
<h4 id="Sample-4"><a href="#Sample-4" class="headerlink" title="Sample"></a>Sample</h4><p>Input:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">5 7 </span><br><span class="line">3 4 7 1 </span><br><span class="line">1 3 2 20 </span><br><span class="line">1 4 17 18 </span><br><span class="line">4 5 25 3 </span><br><span class="line">1 2 10 1 </span><br><span class="line">3 5 4 14 </span><br><span class="line">2 4 6 5</span><br></pre></td></tr></table></figure>

<p>Output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<h4 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution:"></a>Solution:</h4><p>At first we need to know the shortest path for both GPS. And we need to know every point’s distance from the end point n, there is no way we need to use other alogrithm, we can just run sofa from n. How can we calculate how many time the GPS complained? We can simplely enumerate every edge, to see if its value is equal to the head and tail’s shortest length, and use dist[] to memorize how many time will the GPS complain if we across this route. Then we creat a new map based on this dist[], and spfa find the smallest path.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mx=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span><span class="comment">//Same old story</span></span><br><span class="line">	<span class="keyword">int</span> next,dest,val;</span><br><span class="line">&#125;eg[<span class="number">4</span>][mx];</span><br><span class="line"><span class="keyword">int</span> n,m,head[<span class="number">4</span>][mx],top=<span class="number">0</span>,a,b,p,h;<span class="comment">//We need three maps</span></span><br><span class="line"><span class="keyword">int</span> dist[<span class="number">100005</span>];<span class="keyword">bool</span> vis[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> val,<span class="keyword">int</span> mode)</span></span>&#123;<span class="comment">//Same old story just have double the array</span></span><br><span class="line">	eg[mode][top].next=head[mode][u];eg[mode][top].dest=v;</span><br><span class="line">	eg[mode][top].val=val;head[mode][u]=top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> mode)</span></span>&#123;</span><br><span class="line">		<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">		<span class="built_in">memset</span>(dist,<span class="number">0x7f</span>,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">		q.push(s);</span><br><span class="line">		vis[s]=<span class="literal">true</span>;</span><br><span class="line">		dist[s]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">			<span class="keyword">int</span> u=q.front();</span><br><span class="line">			q.pop();</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=head[mode][u];i;i=eg[mode][i].next)&#123;</span><br><span class="line">				<span class="keyword">if</span>(dist[eg[mode][i].dest]&gt;dist[u]+eg[mode][i].val)&#123;</span><br><span class="line">					dist[eg[mode][i].dest]=dist[u]+eg[mode][i].val;</span><br><span class="line">					<span class="keyword">if</span> (!vis[eg[mode][i].dest])&#123;</span><br><span class="line">						q.push(eg[mode][i].dest);</span><br><span class="line">						vis[eg[mode][i].dest]=<span class="number">1</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			vis[u]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//The important part of this question</span></span><br><span class="line">		<span class="keyword">if</span>(mode==<span class="number">3</span>) <span class="built_in">cout</span>&lt;&lt;dist[n];</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//enumerate every points</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j=head[mode][i];j;j=eg[mode][j].next)&#123;</span><br><span class="line">					<span class="keyword">if</span> (dist[i]+eg[mode][j].val==dist[eg[mode][j].dest])&#123;</span><br><span class="line">						eg[<span class="number">3</span>][j].val--;<span class="comment">//For edges in the shortest path, renew it</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		top++;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;p&gt;&gt;h;</span><br><span class="line">		addedge(b,a,p,<span class="number">1</span>);</span><br><span class="line">		addedge(b,a,h,<span class="number">2</span>);</span><br><span class="line">		addedge(a,b,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	spfa(n,<span class="number">1</span>);</span><br><span class="line">	spfa(n,<span class="number">2</span>);</span><br><span class="line">	spfa(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>In this blog we studied DFS, BFS, Dijkstra, Floyd, and SPFA. They have their own advantages so we need to use them properly in competition. Here are a chart about each. Hopefully this woould be helpful to you.</p>
<h4 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h4><table>
<thead>
<tr>
<th align="center">Shortest-PathsProblem</th>
<th align="center">Sparse Graph</th>
<th align="center">Dense Graph</th>
<th align="center">With negative value</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Single-Source</td>
<td align="center">Dijkstra+heap</td>
<td align="center">SPFA/Dijkstra+heap</td>
<td align="center">SPFA</td>
</tr>
<tr>
<td align="center">APSP(Undirected graph)</td>
<td align="center">SPFA/Floyd</td>
<td align="center">SPFA</td>
<td align="center">SPFA</td>
</tr>
<tr>
<td align="center">APSP(Directed graph)</td>
<td align="center">Floyd</td>
<td align="center">SPFA/Dijkstra+heap</td>
<td align="center">SPFA</td>
</tr>
</tbody></table>
<p>​                                                                        APSP((All Pairs Shortest Path))</p>
<h4 id="Complexity"><a href="#Complexity" class="headerlink" title="Complexity"></a>Complexity</h4><table>
<thead>
<tr>
<th align="center">Solving ways</th>
<th align="center">Time Complexity</th>
<th align="center">Space Complexity</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Dijkstra+heap</td>
<td align="center">O(E*lgV)</td>
<td align="center">O(n^2)</td>
</tr>
<tr>
<td align="center">SPFA</td>
<td align="center">O(kE) (Not stable)</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center">Floyd</td>
<td align="center">O(n^3)</td>
<td align="center">O(n)</td>
</tr>
</tbody></table>
<h2 id="Reference-Links"><a href="#Reference-Links" class="headerlink" title="Reference Links:"></a>Reference Links:</h2><p>1.<a href="https://www.luogu.com.cn/problem/P3110" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P3110</a></p>
<p>2.<a href="https://www.luogu.com.cn/problem/P2853" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P2853</a></p>
<p>3.<a href="https://en.wikipedia.org/wiki/Depth-first_search" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Depth-first_search</a></p>
<p>4.<a href="https://en.wikipedia.org/wiki/Breadth-first_search" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Breadth-first_search</a></p>
<p>5.<a href="https://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm</a></p>
<p>6.<a href="https://en.wikipedia.org/wiki/Floyd–Warshall_algorithm" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm</a></p>
<p>7.<a href="https://en.wikipedia.org/wiki/Dijkstra' target="_blank" rel="noopener"s_algorithm">https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm</a></p>
<p>8.<a href="https://blog.csdn.net/qq_35644234/article/details/60870719" target="_blank" rel="noopener">https://blog.csdn.net/qq_35644234/article/details/60870719</a></p>
<p>9.<a href="http://www.usaco.org/index.php?page=viewproblem2&amp;cpid=969&amp;lang=en" target="_blank" rel="noopener">http://www.usaco.org/index.php?page=viewproblem2&amp;cpid=969&amp;lang=en</a></p>
<p>10.<a href="https://www.luogu.com.cn/problem/P2966" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P2966</a></p>
<p>11.<a href="http://wcipeg.com/wiki/Shortest_Path_Faster_Algorithm" target="_blank" rel="noopener">http://wcipeg.com/wiki/Shortest_Path_Faster_Algorithm</a></p>
<p>12.<a href="https://www.cnblogs.com/flipped/p/6830073.html" target="_blank" rel="noopener">https://www.cnblogs.com/flipped/p/6830073.html</a></p>
<p>12.<a href="https://www.luogu.com.cn/problem/P3106" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P3106</a></p>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/Blogs/images/wechatpay.png" alt="Haotian Tang WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/Blogs/images/alipay.png" alt="Haotian Tang Alipay">
        <p>Alipay</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>Haotian Tang
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="https://mavericktang.github.io/Blogs/2020/02/15/Graph%20theory/" title="Graph theory">https://mavericktang.github.io/Blogs/2020/02/15/Graph theory/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>Welcome to my other publishing channels</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/images/wechat_channel.jpg">
            <span class="icon">
              <i class="fa fa-wechat"></i>
            </span>

            <span class="label">WeChat</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/Blogs/tags/C/" rel="tag"># C++</a>
              <a href="/Blogs/tags/Competition/" rel="tag"># Competition</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Blogs/2020/02/10/Attendence%20Taking/" rel="prev" title="Attendence Taking program design">
      <i class="fa fa-chevron-left"></i> Attendence Taking program design
    </a></div>
      <div class="post-nav-item">
    <a href="/Blogs/2020/02/23/%E7%88%AC%E5%8F%96%E8%BF%9B%E5%87%BB%E7%9A%84%E5%B7%A8%E4%BA%BA%E6%BC%AB%E7%94%BB/" rel="next" title="爬取进击的巨人漫画">
      爬取进击的巨人漫画 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Graph-theory-in-Computer-competition"><span class="nav-number">1.</span> <span class="nav-text">Graph theory in Computer competition</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Intro"><span class="nav-number">1.1.</span> <span class="nav-text">Intro</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Basic-Information"><span class="nav-number">1.2.</span> <span class="nav-text">Basic Information</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Restore-the-graph"><span class="nav-number">1.3.</span> <span class="nav-text">Restore the graph!</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Forward-Star"><span class="nav-number">1.3.1.</span> <span class="nav-text">Forward Star</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Graph-traversal"><span class="nav-number">1.4.</span> <span class="nav-text">Graph traversal</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DFS"><span class="nav-number">1.5.</span> <span class="nav-text">DFS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#USACO06DEC-Cow-Picnic"><span class="nav-number">1.5.1.</span> <span class="nav-text">[USACO06DEC] Cow Picnic</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Description"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">Description</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Input"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">Input</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#output"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">output</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sample"><span class="nav-number">1.5.1.4.</span> <span class="nav-text">Sample</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Solution"><span class="nav-number">1.5.1.5.</span> <span class="nav-text">Solution:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BFS"><span class="nav-number">1.6.</span> <span class="nav-text">BFS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#USACO14DEC-Piggy-Back"><span class="nav-number">1.6.1.</span> <span class="nav-text">[USACO14DEC] Piggy Back</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Description-1"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">Description</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Input-1"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">Input</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#output-1"><span class="nav-number">1.6.1.3.</span> <span class="nav-text">output</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sample-1"><span class="nav-number">1.6.1.4.</span> <span class="nav-text">Sample</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Solution-1"><span class="nav-number">1.6.1.5.</span> <span class="nav-text">Solution:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#More-advanced-Algotithm"><span class="nav-number">1.7.</span> <span class="nav-text">More advanced Algotithm</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Dijkstra"><span class="nav-number">1.7.1.</span> <span class="nav-text">Dijkstra</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#USACO19DEC-Milk-Pumping-G"><span class="nav-number">1.7.2.</span> <span class="nav-text">[USACO19DEC]Milk Pumping G</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Description-2"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">Description</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Input-2"><span class="nav-number">1.7.2.2.</span> <span class="nav-text">Input</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#output-2"><span class="nav-number">1.7.2.3.</span> <span class="nav-text">output</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sample-2"><span class="nav-number">1.7.2.4.</span> <span class="nav-text">Sample</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Solution-2"><span class="nav-number">1.7.2.5.</span> <span class="nav-text">Solution:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Floyd"><span class="nav-number">1.7.3.</span> <span class="nav-text">Floyd</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#USACO09DEC-Cow-Toll-Paths"><span class="nav-number">1.7.4.</span> <span class="nav-text">[USACO09DEC]Cow Toll Paths</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Description-3"><span class="nav-number">1.7.4.1.</span> <span class="nav-text">Description</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Input-3"><span class="nav-number">1.7.4.2.</span> <span class="nav-text">Input</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#output-3"><span class="nav-number">1.7.4.3.</span> <span class="nav-text">output</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sample-3"><span class="nav-number">1.7.4.4.</span> <span class="nav-text">Sample</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Solution-3"><span class="nav-number">1.7.4.5.</span> <span class="nav-text">Solution:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SPFA"><span class="nav-number">1.7.5.</span> <span class="nav-text">SPFA</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Difference-between-Dij-heap-and-SPFA"><span class="nav-number">1.7.5.1.</span> <span class="nav-text">Difference between Dij+heap and SPFA!!!</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#USACO14OPEN-Dueling-GPS’s"><span class="nav-number">1.7.6.</span> <span class="nav-text">[USACO14OPEN]Dueling GPS’s</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Description-4"><span class="nav-number">1.7.6.1.</span> <span class="nav-text">Description</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Input-4"><span class="nav-number">1.7.6.2.</span> <span class="nav-text">Input</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#output-4"><span class="nav-number">1.7.6.3.</span> <span class="nav-text">output</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sample-4"><span class="nav-number">1.7.6.4.</span> <span class="nav-text">Sample</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Solution-4"><span class="nav-number">1.7.6.5.</span> <span class="nav-text">Solution:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Conclusion"><span class="nav-number">1.8.</span> <span class="nav-text">Conclusion</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Usage"><span class="nav-number">1.8.0.1.</span> <span class="nav-text">Usage</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Complexity"><span class="nav-number">1.8.0.2.</span> <span class="nav-text">Complexity</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reference-Links"><span class="nav-number">1.9.</span> <span class="nav-text">Reference Links:</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Haotian Tang"
      src="/Blogs/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Haotian Tang</p>
  <div class="site-description" itemprop="description">Live without Barricades!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/Blogs/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/Blogs/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/MaverickTang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;MaverickTang" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/Blogs/agodsfor@gmail.com" title="E-Mail → agodsfor@gmail.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" class="cc-opacity" rel="noopener" target="_blank"><img src="/Blogs/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



        <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=450 src="//music.163.com/outchain/player?type=0&id=2897146797&auto=1&height=430"></iframe>
      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mavericreate</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">NaNm</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">NaN:aN</span>
</div>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.2
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/Blogs/lib/anime.min.js"></script>
  <script src="/Blogs/lib/velocity/velocity.min.js"></script>
  <script src="/Blogs/lib/velocity/velocity.ui.min.js"></script>

<script src="/Blogs/js/utils.js"></script>

<script src="/Blogs/js/motion.js"></script>


<script src="/Blogs/js/schemes/pisces.js"></script>


<script src="/Blogs/js/next-boot.js"></script>

<script src="/Blogs/js/bookmark.js"></script>




  




  
<script src="/Blogs/js/local-search.js"></script>













  

  

</body>
</html>
<!--崩溃欺骗-->
<script type="text/javascript" src="/js/crash_cheat.js"></script>
